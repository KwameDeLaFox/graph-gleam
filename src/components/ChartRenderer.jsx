import React, { useEffect, useRef, useState, useMemo } from 'react';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  ArcElement,
  Title,
  Tooltip,
  Legend,
  Filler,
  RadialLinearScale
} from 'chart.js';
import { Bar, Line, Pie, Doughnut, PolarArea, Scatter } from 'react-chartjs-2';
import { optimizeForPerformance } from '../utils/performance-optimizer';
import { useToast } from './ui/Toast';
import LoadingSpinner from './ui/LoadingSpinner';
import { getCurrentTheme, applyThemeToContainer, resetToDefault, getThemeById } from '../utils/theme-manager';
import './charts.css';

// Register Chart.js components
ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  ArcElement,
  Title,
  Tooltip,
  Legend,
  Filler,
  RadialLinearScale
);

const ChartRenderer = React.forwardRef(({ data, chartType, isLoading, themeId }, ref) => {
  const internalChartRef = useRef(null);
  const [error, setError] = useState(null);
  const [exportingFormat, setExportingFormat] = useState(null);
  const [copyingEmbed, setCopyingEmbed] = useState(false);
  const [isThemeSwitching, setIsThemeSwitching] = useState(false);
  const { addToast } = useToast();

  // Internal export functions
  const exportChart = async (format = 'png', filename = 'chart') => {
    try {
      setExportingFormat(format);
      
      if (!internalChartRef.current?.canvas) {
        addToast('Chart not ready for export', 'error');
        return null;
      }
      
      // Small delay to show loading state
      await new Promise(resolve => setTimeout(resolve, 200));
      
      const canvas = internalChartRef.current.canvas;
      const quality = format === 'jpeg' ? 0.95 : 1.0; // Increased JPEG quality
      const mimeType = `image/${format}`;
      
      // Get current theme for filename and metadata
      const currentTheme = getCurrentTheme();
      
      // Create descriptive filename with theme
      const themeSuffix = currentTheme !== 'default' ? `-${currentTheme}` : '';
      const timestamp = new Date().toISOString().slice(0, 10); // YYYY-MM-DD format
      const finalFilename = `${filename}-${chartType}${themeSuffix}-${timestamp}.${format}`;
      
      // Create high-quality export canvas
      const exportCanvas = await createHighQualityExport(canvas, format);
      
      const link = document.createElement('a');
      link.download = finalFilename;
      link.href = exportCanvas.toDataURL(mimeType, quality);
      link.click();
      
      // Show success message with theme info
      const themeMessage = currentTheme !== 'default' ? ` with ${currentTheme} theme` : '';
      addToast(`Chart exported as ${format.toUpperCase()}${themeMessage}!`, 'success');
      
      return link.href;
    } catch (error) {
      addToast('Failed to export chart', 'error');
      console.error('Export error:', error);
      return null;
    } finally {
      setExportingFormat(null);
    }
  };
  
  // Create high-quality export canvas
  const createHighQualityExport = async (originalCanvas) => {
    // Create a new canvas with higher resolution for better quality
    const exportCanvas = document.createElement('canvas');
    const ctx = exportCanvas.getContext('2d');
    
    // Set higher resolution (2x for retina displays)
    const scale = 2;
    exportCanvas.width = originalCanvas.width * scale;
    exportCanvas.height = originalCanvas.height * scale;
    
    // Scale the context to match the new canvas size
    ctx.scale(scale, scale);
    
    // Draw the original canvas content
    ctx.drawImage(originalCanvas, 0, 0);
    
    return exportCanvas;
  };
  
  const getChartInstance = () => {
    return internalChartRef.current;
  };
  
  const getEmbedCode = () => {
    if (!internalChartRef.current?.canvas) return '';
    
    const dataURL = internalChartRef.current.canvas.toDataURL();
    const currentTheme = getCurrentTheme();
    const themeInfo = currentTheme !== 'default' ? ` (${currentTheme} theme)` : '';
    const embedHTML = `<img src="${dataURL}" alt="Chart generated by Graph Gleam${themeInfo}" style="max-width: 100%; height: auto;" />`;
    
    return embedHTML;
  };

  // Export methods exposed via ref
  React.useImperativeHandle(ref, () => ({
    exportChart,
    getChartInstance,
    getEmbedCode,
    renderChart: () => {
      // Force re-render (handled by useEffect)
      return true;
    }
  }));

  // Helper function to add transparency to colors
  const addTransparency = (color, opacity = 0.2) => {
    if (color.startsWith('rgba(')) {
      // Replace the existing alpha value with the new opacity
      return color.replace(/[\d.]+\)$/, `${opacity})`);
    }
    return color;
  };

  // Get theme-aware colors (memoized for performance)
  const themeColors = useMemo(() => {
    const currentTheme = themeId || getCurrentTheme();
    
    // Use theme colors if available, otherwise fall back to defaults
    if (currentTheme && currentTheme !== 'default') {
      // Get the actual theme object to access color values directly
      const theme = getThemeById(currentTheme);
      if (theme && theme.variables) {
        return [
          theme.variables['--chart-1'],
          theme.variables['--chart-2'],
          theme.variables['--chart-3'],
          theme.variables['--chart-4'],
          theme.variables['--chart-5'],
          theme.variables['--chart-1'], // Repeat for more data series
          theme.variables['--chart-2'],
          theme.variables['--chart-3'],
          theme.variables['--chart-4'],
          theme.variables['--chart-5']
        ];
      }
    }
    
    // Default Chart.js colors
    return [
      'rgba(255, 99, 132, 0.8)',   // Red
      'rgba(54, 162, 235, 0.8)',   // Blue
      'rgba(255, 205, 86, 0.8)',   // Yellow
      'rgba(75, 192, 192, 0.8)',   // Green
      'rgba(153, 102, 255, 0.8)',  // Purple
      'rgba(255, 159, 64, 0.8)',   // Orange
      'rgba(199, 199, 199, 0.8)',  // Grey
      'rgba(83, 102, 255, 0.8)',   // Light Blue
      'rgba(255, 99, 255, 0.8)',   // Pink
      'rgba(99, 255, 132, 0.8)'    // Light Green
    ];
  }, [themeId]);

  // Theme switching animation effect and scoped theme application
  useEffect(() => {
    if (!data || !chartType) return;

    // Get the chart container element
    const chartContainer = document.querySelector('.chart-container');
    
    if (chartContainer) {
      if (themeId && themeId !== 'default') {
        // Apply theme to chart container only
        applyThemeToContainer(themeId, chartContainer);
        setIsThemeSwitching(true);
        const timer = setTimeout(() => setIsThemeSwitching(false), 300);
        return () => clearTimeout(timer);
      } else {
        // Reset to default theme for chart container
        resetToDefault(chartContainer);
      }
    }
  }, [themeId, data, chartType]);

  // Cleanup chart instance on unmount to prevent memory leaks
  useEffect(() => {
    return () => {
      if (internalChartRef.current) {
        internalChartRef.current.destroy();
      }
    };
  }, []);

  // Define chart preparation functions before useMemo
  const prepareBarChartData = (data, numericCols, categoricalCols, colors) => {
    const labels = data.map(row => row[categoricalCols[0]] || 'Unknown');
    const datasets = numericCols.map((col, index) => ({
      label: col,
      data: data.map(row => parseFloat(row[col]) || 0),
      backgroundColor: colors[index % colors.length],
      borderColor: colors[index % colors.length],
      borderWidth: 1,
    }));

    return { labels, datasets };
  };

  const prepareLineChartData = (data, numericCols, categoricalCols, colors) => {
    const labels = data.map(row => row[categoricalCols[0]] || 'Unknown');
    const datasets = numericCols.map((col, index) => ({
      label: col,
      data: data.map(row => parseFloat(row[col]) || 0),
      borderColor: colors[index % colors.length],
      backgroundColor: addTransparency(colors[index % colors.length], 0.1),
      borderWidth: 2,
      fill: false,
      tension: 0.4,
    }));

    return { labels, datasets };
  };

  const preparePieChartData = (data, numericCols, categoricalCols, colors) => {
    const labels = data.map(row => row[categoricalCols[0]] || 'Unknown');
    const values = data.map(row => parseFloat(row[numericCols[0]]) || 0);

    return {
      labels,
      datasets: [{
        data: values,
        backgroundColor: colors.slice(0, labels.length),
        borderColor: '#fff',
        borderWidth: 2,
      }]
    };
  };

  const prepareAreaChartData = (data, numericCols, categoricalCols, colors) => {
    const labels = data.map(row => row[categoricalCols[0]] || 'Unknown');
    const datasets = numericCols.map((col, index) => ({
      label: col,
      data: data.map(row => parseFloat(row[col]) || 0),
      borderColor: colors[index % colors.length],
      backgroundColor: addTransparency(colors[index % colors.length], 0.3),
      borderWidth: 2,
      fill: true,
      tension: 0.4,
    }));

    return { labels, datasets };
  };

  const prepareScatterChartData = (data, numericCols, colors) => {
    if (numericCols.length < 2) {
      throw new Error('Scatter plot requires at least 2 numeric columns');
    }

    const xCol = numericCols[0];
    const yCol = numericCols[1];

    return {
      datasets: [{
        label: `${yCol} vs ${xCol}`,
        data: data.map(row => ({
          x: parseFloat(row[xCol]) || 0,
          y: parseFloat(row[yCol]) || 0,
        })),
        backgroundColor: colors[0],
        borderColor: colors[0],
        borderWidth: 1,
        pointRadius: 4,
      }]
    };
  };

  const getBaseChartOptions = () => {
    return {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          position: 'top',
          labels: {
            usePointStyle: true,
            padding: 20
          },
        },
        tooltip: {
          backgroundColor: 'rgba(0, 0, 0, 0.8)',
          titleColor: '#fff',
          bodyColor: '#fff',
          borderColor: 'rgba(0, 0, 0, 0.1)',
          borderWidth: 1,
          cornerRadius: 8,
          displayColors: true,
        },
      },
      scales: {
        x: {
          grid: {
            color: 'rgba(0, 0, 0, 0.1)',
            drawBorder: false
          },
        },
        y: {
          grid: {
            color: 'rgba(0, 0, 0, 0.1)',
            drawBorder: false
          },
        },
      },
    };
  };

  const getBarChartOptions = () => {
    return {
      ...getBaseChartOptions(),
      scales: {
        ...getBaseChartOptions().scales,
        y: {
          ...getBaseChartOptions().scales.y,
          beginAtZero: true,
        },
      },
    };
  };

  const getLineChartOptions = () => {
    return {
      ...getBaseChartOptions(),
      scales: {
        ...getBaseChartOptions().scales,
        y: {
          ...getBaseChartOptions().scales.y,
          beginAtZero: true,
        },
      },
    };
  };

  const getPieChartOptions = () => {
    return {
      ...getBaseChartOptions(),
      plugins: {
        ...getBaseChartOptions().plugins,
        legend: {
          ...getBaseChartOptions().plugins.legend,
          position: 'right',
        },
      },
    };
  };

  const getDoughnutChartOptions = () => {
    return {
      ...getPieChartOptions(),
      cutout: '60%',
    };
  };

  const getAreaChartOptions = () => {
    return {
      ...getLineChartOptions(),
    };
  };

  const getScatterChartOptions = () => {
    return {
      ...getBaseChartOptions(),
      scales: {
        x: {
          type: 'linear',
          position: 'bottom',
          grid: {
            color: 'rgba(0, 0, 0, 0.1)',
            drawBorder: false
          },
        },
        y: {
          type: 'linear',
          position: 'left',
          grid: {
            color: 'rgba(0, 0, 0, 0.1)',
            drawBorder: false
          },
        },
      },
    };
  };

  const prepareChartData = (rawData, type) => {
    if (!rawData || rawData.length === 0) {
      throw new Error('No data provided for chart');
    }

    // Optimize data for performance
    const optimizationResult = optimizeForPerformance(rawData);
    const optimizedData = optimizationResult.data;
    
    // Get column names
    const columns = Object.keys(optimizedData[0] || {});
    if (columns.length === 0) {
      throw new Error('No columns found in data');
    }

    // Find numeric and categorical columns
    const numericColumns = columns.filter(col => 
      typeof optimizedData[0][col] === 'number' || !isNaN(optimizedData[0][col])
    );
    const categoricalColumns = columns.filter(col => 
      typeof optimizedData[0][col] === 'string' && isNaN(optimizedData[0][col])
    );

    // Use memoized theme colors
    const colors = themeColors;

    let chartData = {};
    let options = {};

    switch (type) {
      case 'bar':
        chartData = prepareBarChartData(optimizedData, numericColumns, categoricalColumns, colors);
        options = getBarChartOptions();
        break;
      case 'line':
        chartData = prepareLineChartData(optimizedData, numericColumns, categoricalColumns, colors);
        options = getLineChartOptions();
        break;
      case 'pie':
        chartData = preparePieChartData(optimizedData, numericColumns, categoricalColumns, colors);
        options = getPieChartOptions();
        break;
      case 'doughnut':
        chartData = preparePieChartData(optimizedData, numericColumns, categoricalColumns, colors);
        options = getDoughnutChartOptions();
        break;
      case 'area':
        chartData = prepareAreaChartData(optimizedData, numericColumns, categoricalColumns, colors);
        options = getAreaChartOptions();
        break;
      case 'scatter':
        chartData = prepareScatterChartData(optimizedData, numericColumns, colors);
        options = getScatterChartOptions();
        break;
      default:
        throw new Error(`Unsupported chart type: ${type}`);
    }

    return { chartData, options };
  };

  // Memoized chart data preparation for performance
  const { chartData, chartOptions } = useMemo(() => {
    if (!data || !chartType) {
      return { chartData: null, chartOptions: null };
    }

    try {
      const { chartData: preparedData, options } = prepareChartData(data, chartType);
      return { chartData: preparedData, chartOptions: options };
    } catch (err) {
      console.error('Chart preparation error:', err);
      setError(err.message);
      return { chartData: null, chartOptions: null };
    }
  }, [data, chartType, themeColors]); // Use themeColors instead of themeId for better memoization

  const renderChart = () => {
    if (!chartData || !chartOptions) {
      return null;
    }

    const chartProps = {
      ref: internalChartRef,
      data: chartData,
      options: chartOptions,
    };

    switch (chartType) {
      case 'bar':
        return <Bar {...chartProps} />;
      case 'line':
        return <Line {...chartProps} />;
      case 'pie':
        return <Pie {...chartProps} />;
      case 'doughnut':
        return <Doughnut {...chartProps} />;
      case 'area':
        return <Line {...chartProps} />;
      case 'scatter':
        return <Scatter {...chartProps} />;
      default:
        return null;
    }
  };

  // Handle copy embed code
  const handleCopyEmbed = async () => {
    try {
      setCopyingEmbed(true);
      const embedCode = getEmbedCode();
      
      if (!embedCode) {
        addToast('No chart available to embed', 'error');
        return;
      }
      
      await navigator.clipboard.writeText(embedCode);
      addToast('Embed code copied to clipboard!', 'success');
    } catch (error) {
      addToast('Failed to copy embed code', 'error');
      console.error('Copy error:', error);
    } finally {
      setCopyingEmbed(false);
    }
  };

  // Handle PNG export
  const handleExportPNG = async () => {
    await exportChart('png', 'graph-gleam');
  };

  // Handle JPEG export
  const handleExportJPEG = async () => {
    await exportChart('jpeg', 'graph-gleam');
  };

  // Clear error when data or chart type changes
  useEffect(() => {
    if (error) {
      setError(null);
    }
  }, [data, chartType]);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64 bg-muted/20 rounded-lg">
        <LoadingSpinner />
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex items-center justify-center h-64 bg-destructive/10 rounded-lg border border-destructive/20">
        <div className="text-center">
          <div className="text-destructive text-lg font-semibold mb-2">Chart Error</div>
          <div className="text-destructive/80 text-sm">{error}</div>
        </div>
      </div>
    );
  }

  if (!data || !chartType) {
    return (
      <div className="flex items-center justify-center h-64 bg-muted/20 rounded-lg">
        <div className="text-center text-muted-foreground">
          <div className="text-lg font-semibold mb-2">No Chart Data</div>
          <div className="text-sm">Upload data and select a chart type to get started</div>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Chart Container */}
      <div className={`chart-container bg-card rounded-lg border border-border shadow-sm p-6 ${isThemeSwitching ? 'theme-switching' : ''}`}>
        <div className="chart-renderer" style={{ height: '400px', position: 'relative' }}>
          {renderChart()}
        </div>
      </div>

      {/* Chart Info */}
      <div className="bg-muted/20 rounded-lg p-4">
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
          <div>
            <span className="font-medium text-foreground">Chart Type:</span>
            <span className="ml-2 text-muted-foreground capitalize">{chartType}</span>
          </div>
          <div>
            <span className="font-medium text-foreground">Data Points:</span>
            <span className="ml-2 text-muted-foreground">{data.length}</span>
          </div>
          <div>
            <span className="font-medium text-foreground">Theme:</span>
            <span className="ml-2 text-muted-foreground capitalize">
              {themeId && themeId !== 'default' ? themeId : 'Default'}
            </span>
          </div>
        </div>
      </div>

      {/* Export Controls */}
      <div className="flex flex-wrap gap-3">
        <button
          onClick={handleExportPNG}
          disabled={exportingFormat === 'png'}
          className="px-4 py-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90 transition-colors flex items-center gap-2 disabled:opacity-50"
        >
          {exportingFormat === 'png' ? <LoadingSpinner size="sm" /> : 'ðŸ“¥ PNG Export'}
        </button>
        <button
          onClick={handleExportJPEG}
          disabled={exportingFormat === 'jpeg'}
          className="px-4 py-2 bg-secondary text-secondary-foreground rounded-md hover:bg-secondary/90 transition-colors flex items-center gap-2 disabled:opacity-50"
        >
          {exportingFormat === 'jpeg' ? <LoadingSpinner size="sm" /> : 'ðŸ“· JPEG Export'}
        </button>
        <button
          onClick={handleCopyEmbed}
          disabled={copyingEmbed}
          className="px-4 py-2 bg-muted text-muted-foreground rounded-md hover:bg-muted/80 transition-colors flex items-center gap-2 disabled:opacity-50"
        >
          {copyingEmbed ? <LoadingSpinner size="sm" /> : 'ðŸ“‹ Copy Embed'}
        </button>
      </div>
    </div>
  );
});

ChartRenderer.displayName = 'ChartRenderer';

export default ChartRenderer; 