import React, { useEffect, useRef, useState } from 'react';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  ArcElement,
  Title,
  Tooltip,
  Legend,
  Filler,
  RadialLinearScale
} from 'chart.js';
import { Bar, Line, Pie, Doughnut, PolarArea, Scatter } from 'react-chartjs-2';
import { optimizeForPerformance } from '../utils/performance-optimizer';
import { useToast } from './ui/Toast';
import LoadingSpinner from './ui/LoadingSpinner';
import './charts.css';

// Register Chart.js components
ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  ArcElement,
  Title,
  Tooltip,
  Legend,
  Filler,
  RadialLinearScale
);

const ChartRenderer = React.forwardRef(({ data, chartType, isLoading }, ref) => {
  const internalChartRef = useRef(null);
  const [chartData, setChartData] = useState(null);
  const [chartOptions, setChartOptions] = useState(null);
  const [error, setError] = useState(null);
  const [exportingFormat, setExportingFormat] = useState(null);
  const [copyingEmbed, setCopyingEmbed] = useState(false);
  const { addToast } = useToast();

  // Internal export functions
  const exportChart = async (format = 'png', filename = 'chart') => {
    try {
      setExportingFormat(format);
      
      if (!internalChartRef.current?.canvas) {
        addToast('Chart not ready for export', 'error');
        return null;
      }
      
      // Small delay to show loading state
      await new Promise(resolve => setTimeout(resolve, 200));
      
      const canvas = internalChartRef.current.canvas;
      const quality = format === 'jpeg' ? 0.9 : 1.0;
      const mimeType = `image/${format}`;
      
      const link = document.createElement('a');
      link.download = `${filename}-${chartType}-${Date.now()}.${format}`;
      link.href = canvas.toDataURL(mimeType, quality);
      link.click();
      
      addToast(`Chart exported as ${format.toUpperCase()}!`, 'success');
      return link.href;
    } catch (error) {
      addToast('Failed to export chart', 'error');
      console.error('Export error:', error);
      return null;
    } finally {
      setExportingFormat(null);
    }
  };
  
  const getChartInstance = () => {
    return internalChartRef.current;
  };
  
  const getEmbedCode = () => {
    if (!internalChartRef.current?.canvas) return '';
    
    const dataURL = internalChartRef.current.canvas.toDataURL();
    const embedHTML = `<img src="${dataURL}" alt="Chart generated by Graph Gleam" style="max-width: 100%; height: auto;" />`;
    
    return embedHTML;
  };

  // Export methods exposed via ref
  React.useImperativeHandle(ref, () => ({
    exportChart,
    getChartInstance,
    getEmbedCode,
    renderChart: () => {
      // Force re-render (handled by useEffect)
      return true;
    }
  }));

  // Helper function to add transparency to colors
  const addTransparency = (color, opacity = 0.2) => {
    if (color.startsWith('rgba(')) {
      // Replace the existing alpha value with the new opacity
      return color.replace(/[\d\.]+\)$/, `${opacity})`);
    }
    return color;
  };

  useEffect(() => {
    if (!data || !chartType) return;

    try {
      const { chartData, options } = prepareChartData(data, chartType);
      setChartData(chartData);
      setChartOptions(options);
      setError(null);
    } catch (err) {
      console.error('Chart preparation error:', err);
      setError(err.message);
    }
  }, [data, chartType]);

  const prepareChartData = (rawData, type) => {
    if (!rawData || rawData.length === 0) {
      throw new Error('No data provided for chart');
    }

    // Optimize data for performance
    const optimizationResult = optimizeForPerformance(rawData);
    const optimizedData = optimizationResult.data;
    
    // Get column names
    const columns = Object.keys(optimizedData[0] || {});
    if (columns.length === 0) {
      throw new Error('No columns found in data');
    }

    // Find numeric and categorical columns
    const numericColumns = columns.filter(col => 
      typeof optimizedData[0][col] === 'number' || !isNaN(optimizedData[0][col])
    );
    const categoricalColumns = columns.filter(col => 
      typeof optimizedData[0][col] === 'string' && isNaN(optimizedData[0][col])
    );

    // Use Chart.js default color palette
    const getChartColors = () => {
      return [
        'rgba(255, 99, 132, 0.8)',   // Red
        'rgba(54, 162, 235, 0.8)',   // Blue
        'rgba(255, 205, 86, 0.8)',   // Yellow
        'rgba(75, 192, 192, 0.8)',   // Green
        'rgba(153, 102, 255, 0.8)',  // Purple
        'rgba(255, 159, 64, 0.8)',   // Orange
        'rgba(199, 199, 199, 0.8)',  // Grey
        'rgba(83, 102, 255, 0.8)',   // Light Blue
        'rgba(255, 99, 255, 0.8)',   // Pink
        'rgba(99, 255, 132, 0.8)'    // Light Green
      ];
    };

    const colors = getChartColors();

    let chartData = {};
    let options = {};

    switch (type) {
      case 'bar':
        chartData = prepareBarChartData(optimizedData, numericColumns, categoricalColumns, colors);
        options = getBarChartOptions();
        break;
      case 'line':
        chartData = prepareLineChartData(optimizedData, numericColumns, categoricalColumns, colors);
        options = getLineChartOptions();
        break;
      case 'pie':
        chartData = preparePieChartData(optimizedData, numericColumns, categoricalColumns, colors);
        options = getPieChartOptions();
        break;
      case 'doughnut':
        chartData = preparePieChartData(optimizedData, numericColumns, categoricalColumns, colors);
        options = getDoughnutChartOptions();
        break;
      case 'area':
        chartData = prepareAreaChartData(optimizedData, numericColumns, categoricalColumns, colors);
        options = getAreaChartOptions();
        break;
      case 'scatter':
        chartData = prepareScatterChartData(optimizedData, numericColumns, colors);
        options = getScatterChartOptions();
        break;
      default:
        throw new Error(`Unsupported chart type: ${type}`);
    }

    return { chartData, options };
  };

  const prepareBarChartData = (data, numericCols, categoricalCols, colors) => {
    const labels = data.map(row => row[categoricalCols[0]] || 'Unknown');
    const datasets = numericCols.map((col, index) => ({
      label: col,
      data: data.map(row => parseFloat(row[col]) || 0),
      backgroundColor: colors[index % colors.length],
      borderColor: colors[index % colors.length],
      borderWidth: 1,
    }));

    return { labels, datasets };
  };

  const prepareLineChartData = (data, numericCols, categoricalCols, colors) => {
    const labels = data.map(row => row[categoricalCols[0]] || 'Unknown');
    const datasets = numericCols.map((col, index) => ({
      label: col,
      data: data.map(row => parseFloat(row[col]) || 0),
      borderColor: colors[index % colors.length],
      backgroundColor: addTransparency(colors[index % colors.length], 0.1),
      borderWidth: 2,
      fill: false,
      tension: 0.4,
    }));

    return { labels, datasets };
  };

  const preparePieChartData = (data, numericCols, categoricalCols, colors) => {
    const labels = data.map(row => row[categoricalCols[0]] || 'Unknown');
    const values = data.map(row => parseFloat(row[numericCols[0]]) || 0);

    return {
      labels,
      datasets: [{
        data: values,
        backgroundColor: colors.slice(0, labels.length),
        borderColor: '#fff',
        borderWidth: 2,
      }]
    };
  };

  const prepareAreaChartData = (data, numericCols, categoricalCols, colors) => {
    const labels = data.map(row => row[categoricalCols[0]] || 'Unknown');
    const datasets = numericCols.map((col, index) => ({
      label: col,
      data: data.map(row => parseFloat(row[col]) || 0),
      borderColor: colors[index % colors.length],
      backgroundColor: addTransparency(colors[index % colors.length], 0.3),
      borderWidth: 2,
      fill: true,
      tension: 0.4,
    }));

    return { labels, datasets };
  };

  const prepareScatterChartData = (data, numericCols, colors) => {
    if (numericCols.length < 2) {
      throw new Error('Scatter plot requires at least 2 numeric columns');
    }

    const xCol = numericCols[0];
    const yCol = numericCols[1];

    return {
      datasets: [{
        label: `${yCol} vs ${xCol}`,
        data: data.map(row => ({
          x: parseFloat(row[xCol]) || 0,
          y: parseFloat(row[yCol]) || 0,
        })),
        backgroundColor: colors[0],
        borderColor: colors[0],
        borderWidth: 1,
        pointRadius: 4,
      }]
    };
  };

  const getBaseChartOptions = () => {
    return {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          position: 'top',
          labels: {
            usePointStyle: true,
            padding: 20
          },
        },
        tooltip: {
          backgroundColor: 'rgba(0, 0, 0, 0.8)',
          titleColor: '#fff',
          bodyColor: '#fff',
          borderColor: 'rgba(0, 0, 0, 0.1)',
          borderWidth: 1,
          cornerRadius: 8,
          displayColors: true,
        },
      },
      scales: {
        x: {
          grid: {
            color: 'rgba(0, 0, 0, 0.1)',
            drawBorder: false
          },
        },
        y: {
          grid: {
            color: 'rgba(0, 0, 0, 0.1)',
            drawBorder: false
          },
        },
      },
    };
  };

  const getBarChartOptions = () => {
    const baseOptions = getBaseChartOptions();
    return {
      ...baseOptions,
      plugins: {
        ...baseOptions.plugins,
        title: {
          display: true,
          text: 'Bar Chart',
        },
      },
    };
  };

  const getLineChartOptions = () => {
    const baseOptions = getBaseChartOptions();
    return {
      ...baseOptions,
      plugins: {
        ...baseOptions.plugins,
        title: {
          display: true,
          text: 'Line Chart',
        },
      },
    };
  };

  const getPieChartOptions = () => {
    const baseOptions = getBaseChartOptions();
    return {
      ...baseOptions,
      plugins: {
        ...baseOptions.plugins,
        title: {
          display: true,
          text: 'Pie Chart',
        },
      },
    };
  };

  const getDoughnutChartOptions = () => {
    const baseOptions = getBaseChartOptions();
    return {
      ...baseOptions,
      plugins: {
        ...baseOptions.plugins,
        title: {
          display: true,
          text: 'Doughnut Chart',
        },
      },
      cutout: '60%',
    };
  };

  const getAreaChartOptions = () => {
    const baseOptions = getBaseChartOptions();
    return {
      ...baseOptions,
      plugins: {
        ...baseOptions.plugins,
        title: {
          display: true,
          text: 'Area Chart',
        },
      },
    };
  };

  const getScatterChartOptions = () => {
    const baseOptions = getBaseChartOptions();
    return {
      ...baseOptions,
      plugins: {
        ...baseOptions.plugins,
        title: {
          display: true,
          text: 'Scatter Plot',
        },
      },
    };
  };

  const renderChart = () => {
    if (!chartData || !chartOptions) return null;

    const chartProps = {
      ref: internalChartRef,
      data: chartData,
      options: chartOptions,
    };

    // Wrap chart in isolated container to prevent CSS interference
    const chartElement = (() => {
      switch (chartType) {
        case 'bar':
          return <Bar {...chartProps} />;
        case 'line':
          return <Line {...chartProps} />;
        case 'pie':
          return <Pie {...chartProps} />;
        case 'doughnut':
          return <Doughnut {...chartProps} />;
        case 'area':
          return <Line {...chartProps} />;
        case 'scatter':
          return <Scatter {...chartProps} />;
        default:
          return <div className="text-center text-muted-foreground">Unsupported chart type</div>;
      }
    })();

    return (
      <div className="chart-container">
        {chartElement}
      </div>
    );
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-96 bg-muted/20 rounded-lg border border-border">
        <div className="text-center">
          <LoadingSpinner size="xl" className="mx-auto mb-4" />
          <p className="text-muted-foreground font-medium">Generating chart...</p>
          <p className="text-xs text-muted-foreground/70 mt-1">This may take a few seconds</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex items-center justify-center h-96 bg-destructive/10 rounded-lg border border-destructive/20">
        <div className="text-center">
          <div className="w-12 h-12 bg-destructive rounded-full flex items-center justify-center mx-auto mb-4">
            <svg className="w-6 h-6 text-destructive-foreground" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
            </svg>
          </div>
          <h3 className="font-medium text-destructive mb-2">Chart Error</h3>
          <p className="text-sm text-destructive/80">{error}</p>
        </div>
      </div>
    );
  }

  return (
    <div className="w-full">
      <div className="bg-card rounded-lg border border-border p-6">
        <div className="h-96 w-full">
          {renderChart()}
        </div>
      </div>
      
      {/* Chart metadata */}
      {chartData && (
        <div className="mt-4 p-4 bg-muted/50 rounded-lg border border-border">
          <div className="flex flex-wrap items-center justify-between gap-4 text-sm">
            <div className="flex flex-wrap items-center gap-4 text-muted-foreground">
              <span>ðŸ“Š {data.length} data points</span>
              <span>ðŸ“ˆ {chartType.charAt(0).toUpperCase() + chartType.slice(1)} chart</span>
              {data.length > 1000 && (
                <span className="text-primary font-medium">âš¡ Optimized for performance</span>
              )}
            </div>
            <div className="flex items-center gap-2">
              <button
                onClick={() => exportChart('png', `chart-${chartType}`)}
                disabled={exportingFormat === 'png'}
                className="px-3 py-1 bg-primary text-primary-foreground rounded-md text-xs hover:bg-primary/90 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-1"
                title="Download chart as PNG image"
              >
                {exportingFormat === 'png' ? (
                  <LoadingSpinner size="xs" color="white" />
                ) : (
                  'ðŸ“¥'
                )} PNG
              </button>
              
              <button
                onClick={() => exportChart('jpeg', `chart-${chartType}`)}
                disabled={exportingFormat === 'jpeg'}
                className="px-3 py-1 bg-secondary text-secondary-foreground rounded-md text-xs hover:bg-secondary/90 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-1"
                title="Download chart as JPEG image"
              >
                {exportingFormat === 'jpeg' ? (
                  <LoadingSpinner size="xs" color="gray" />
                ) : (
                  'ðŸ“·'
                )} JPEG
              </button>
              
              <button
                onClick={async () => {
                  setCopyingEmbed(true);
                  try {
                    const embedCode = getEmbedCode();
                    if (embedCode) {
                      // Small delay to show loading state
                      await new Promise(resolve => setTimeout(resolve, 300));
                      
                      try {
                        await navigator.clipboard.writeText(embedCode);
                        addToast('Embed code copied to clipboard!', 'success');
                      } catch (clipboardError) {
                        // Fallback for older browsers
                        const textArea = document.createElement('textarea');
                        textArea.value = embedCode;
                        document.body.appendChild(textArea);
                        textArea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textArea);
                        addToast('Embed code copied to clipboard!', 'success');
                      }
                    } else {
                      addToast('Chart not ready for embed code', 'error');
                    }
                  } catch (error) {
                    addToast('Failed to copy embed code', 'error');
                  } finally {
                    setCopyingEmbed(false);
                  }
                }}
                disabled={copyingEmbed}
                className="px-3 py-1 bg-accent text-accent-foreground rounded-md text-xs hover:bg-accent/90 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-1"
                title="Copy embed code to clipboard"
              >
                {copyingEmbed ? (
                  <LoadingSpinner size="xs" color="gray" />
                ) : (
                  'ðŸ“‹'
                )} Embed
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
});

export default ChartRenderer; 